package org.eclipse.xtend.ide.tests.smoke;

import com.google.inject.Inject;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.ui.IWorkbench;
import org.eclipse.xtend.ide.tests.AbstractXtendUITestCase;
import org.eclipse.xtend.ide.tests.WorkbenchTestHelper;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.ui.editor.XtextEditor;
import org.eclipse.xtext.ui.editor.model.IXtextDocument;
import org.eclipse.xtext.ui.refactoring.ui.SyncUtil;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.eclipse.xtext.xbase.lib.Extension;
import org.junit.Ignore;
import org.junit.Test;

/**
 * Used to detect deadlocks and race-conditions in the document locking / reconciling strategies.
 * Doesn't contain any assertions, so this is set to {@link Ignore}. To use it, turn up the log
 * level and inspect the log.
 * 
 * @author Jan Koehnlein
 */
@Ignore
@SuppressWarnings("all")
public class ReconcilerSmokeTest extends AbstractXtendUITestCase {
  @Inject
  @Extension
  private WorkbenchTestHelper _workbenchTestHelper;
  
  @Inject
  @Extension
  private SyncUtil _syncUtil;
  
  @Inject
  private IWorkbench workbench;
  
  @Test
  public void testRegionOverlap() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("package org.eclipse.xtext.xbase.formatting");
      _builder.newLine();
      _builder.newLine();
      _builder.append("import com.google.inject.Inject");
      _builder.newLine();
      _builder.append("import java.util.Collection");
      _builder.newLine();
      _builder.append("import java.util.List");
      _builder.newLine();
      _builder.append("import org.eclipse.emf.ecore.EObject");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.AbstractRule");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.CrossReference");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.Keyword");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.RuleCall");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.common.types.JvmFormalParameter");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.common.types.JvmParameterizedTypeReference");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.common.types.JvmTypeConstraint");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.common.types.JvmTypeParameter");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.common.types.JvmWildcardTypeReference");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.nodemodel.ICompositeNode");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.nodemodel.INode");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XAbstractFeatureCall");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XAssignment");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XBinaryOperation");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XBlockExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XCatchClause");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XClosure");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XCollectionLiteral");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XConstructorCall");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XDoWhileExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XFeatureCall");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XForLoopExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XIfExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XMemberFeatureCall");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XReturnExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XSwitchExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XThrowExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XTryCatchFinallyExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XTypeLiteral");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XVariableDeclaration");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.XWhileExpression");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xbase.services.XbaseGrammarAccess");
      _builder.newLine();
      _builder.append("import org.eclipse.xtext.xtype.XFunctionTypeRef");
      _builder.newLine();
      _builder.newLine();
      _builder.append("import static org.eclipse.xtext.common.types.TypesPackage$Literals.*");
      _builder.newLine();
      _builder.append("import static org.eclipse.xtext.xbase.XbasePackage$Literals.*");
      _builder.newLine();
      _builder.append("import static org.eclipse.xtext.xbase.formatting.BasicFormatterPreferenceKeys.*");
      _builder.newLine();
      _builder.append("import static org.eclipse.xtext.xbase.formatting.XbaseFormatterPreferenceKeys.*");
      _builder.newLine();
      _builder.newLine();
      _builder.append("class XbaseFormatter2 extends AbstractFormatter {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("@Inject extension NodeModelAccess");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("@Inject extension HiddenLeafAccess");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("@Inject extension FormattingDataFactory");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("@Inject extension XbaseGrammarAccess");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XCollectionLiteral literal, FormattableDocument document) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("document += literal.nodeForKeyword(\'#\').append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var node = literal.nodeForKeyword(\"[\") ?: literal.nodeForKeyword(\"{\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (value : literal.elements) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("document += node.append[if (value == literal.elements.head) noSpace else oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("value.format(document)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("node = value.nodeForEObject.immediatelyFollowingKeyword(\",\")");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("document += node.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("node = literal.nodeForKeyword(\"]\") ?: literal.nodeForKeyword(\"}\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("document += (node).prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XAnnotation ann, FormattableDocument document) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("ann.nodeForKeyword(\"@\") => [document += append[noSpace]]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("ann.nodeForKeyword(\"(\") => [document += prepend[noSpace] document += append[noSpace]]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (ann.value != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("ann.value.format(document)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("ann.nodeForKeyword(\")\") => [document += prepend[noSpace]]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else if (!ann.elementValuePairs.empty) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (pair : ann.elementValuePairs) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("pair.nodeForKeyword(\"=\") => [document += prepend[noSpace] document += append[noSpace]]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("pair.value.format(document)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("val separator = pair.nodeForEObject.immediatelyFollowingKeyword(\",\")");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("document += separator.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("document += separator.append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("ann.nodeForKeyword(\")\") => [document += prepend[noSpace]]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(JvmGenericArrayTypeReference array, FormattableDocument document) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("document += array.nodeForKeyword(\"[\").prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("document += array.nodeForKeyword(\"]\").prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("array.componentType.format(document)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XFunctionTypeRef func, FormattableDocument document) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("document += func.nodeForKeyword(\"(\").append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (param : func.paramTypes) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("param.format(document)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("document += param.nodeForEObject.immediatelyFollowingKeyword(\",\").surround([noSpace], [oneSpace])");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("document += func.nodeForKeyword(\")\").surround([if (!func.paramTypes.empty) noSpace], [noSpace])");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("document += func.nodeForKeyword(\"=>\").append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("func.returnType.format(document)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(JvmTypeParameter ref, FormattableDocument document) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (c : ref.constraints) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("document += c.nodeForEObject.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("c.format(document)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(JvmParameterizedTypeReference ref, FormattableDocument document) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("document += ref.nodeForKeyword(\"<\").surround[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (arg : ref.arguments) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("arg.format(document)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("document += arg.nodeForEObject.immediatelyFollowingKeyword(\",\").surround([noSpace], [oneSpace])");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (!ref.arguments.empty)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("document += ref.nodeForKeyword(\">\").prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(JvmWildcardTypeReference ref, FormattableDocument document) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (!ref.constraints.empty)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("document += ref.nodeForKeyword(\"?\").append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (c : ref.constraints)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("c.format(document)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(JvmTypeConstraint constraint, FormattableDocument document) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("document += constraint.nodeForFeature(JVM_TYPE_CONSTRAINT__TYPE_REFERENCE).prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("constraint.typeReference.format(document)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XVariableDeclaration expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForKeyword(\"val\").append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForKeyword(\"var\").append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForFeature(XVARIABLE_DECLARATION__TYPE).append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForKeyword(\"=\").surround[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.type.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.right.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XAssignment expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForKeyword(\"=\").surround[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.assignable.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.value.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected void formatStaticQualifier(INode node, FormattableDocument document) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (node instanceof ICompositeNode) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val leafs = (node as ICompositeNode).leafNodes");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (n : leafs)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (n.grammarElement instanceof Keyword && n.text == \"::\") {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("document += n.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (n != leafs.last)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("document += n.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected boolean fitsIntoLine(FormattableDocument fmt, EObject expression) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val node = expression.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val lookahead = fmt.lookahead(expression)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (node == null || lookahead.contains(\"\\n\")) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("return false");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val length = fmt.lineLengthBefore(node.offset) + lookahead.length");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("return length <= fmt.cfg.get(maxLineWidth)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected String lookahead(FormattableDocument fmt, EObject expression) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val lookahead = new FormattableDocument(fmt)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format(expression, lookahead)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val node = expression.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (node != null)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("lookahead.renderToString(node.offset, node.length)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("\"\"");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected void formatFeatureCallParamsWrapIfNeeded(INode open, List<XExpression> params,");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val builder = params.builder");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val explicitParams = params.explicitParams");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var INode node = null");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var indented = false");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (explicitParams.empty) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (arg : explicitParams) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (arg == explicitParams.head) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("val head = arg.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (format.fitsIntoLine(arg)) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += head.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += head.prepend[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("if (!indented)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += head.prepend[increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("indented = true");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("} else if (node != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (format.fitsIntoLine(arg)) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += node.append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += node.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("if (!indented)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += node.append[increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("indented = true");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (arg == explicitParams.last) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += arg.nodeForEObject.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("arg.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("node = arg.nodeForEObject.immediatelyFollowingKeyword(\",\")");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += node.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (indented)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += explicitParams.last.nodeForEObject.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (builder != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += builder.nodeForEObject.prepend [");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (builder.isMultilineLambda)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("oneSpace");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("noSpace");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("builder.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected XClosure builder(List<XExpression> params) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (params.last != null){");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val grammarElement = (params.last.nodeForEObject as ICompositeNode).firstChild.grammarElement");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if(grammarElement == XMemberFeatureCallAccess.memberCallArgumentsXClosureParserRuleCall_1_1_4_0 || grammarElement == XFeatureCallAccess.getFeatureCallArgumentsXClosureParserRuleCall_5_0)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("params.last as XClosure");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected Iterable<XExpression> explicitParams(List<XExpression> params) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val builder = params.builder");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (builder != null) params.take(params.size - 1) else params");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected void formatFeatureCallParamsMultiline(INode open, List<XExpression> params, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val builder = params.builder");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val explicitParams = params.explicitParams");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var INode node = null");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (explicitParams.empty) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (arg : explicitParams) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (arg == explicitParams.head) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("val head = arg.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += head.prepend[newLine; increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("} else if (node != null)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += node.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (arg == explicitParams.last)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += arg.nodeForEObject.append[newLine; decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("arg.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("node = arg.nodeForEObject.immediatelyFollowingKeyword(\",\")");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += node.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (builder != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += builder.nodeForEObject.prepend [");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (builder.isMultilineLambda)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("oneSpace");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("noSpace");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("builder.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("/**");
      _builder.newLine();
      _builder.append("\t ");
      _builder.append("* checks whether the given lambda should be formatted as a block.");
      _builder.newLine();
      _builder.append("\t ");
      _builder.append("* That includes newlines after and before the brackets, and a fresh line for each expression.");
      _builder.newLine();
      _builder.append("\t ");
      _builder.append("*/");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected boolean isMultilineLambda(XClosure closure) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val closingBracket = closure.nodeForKeyword(\']\')");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (closingBracket?.hiddenLeafsBefore != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("return closingBracket.hiddenLeafsBefore.newLines > 0");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return switch block : closure.expression {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("XBlockExpression: block.expressions.size > 1 && block.expressions.eachExpressionInOwnLine");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("default : false");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected boolean isEachExpressionInOwnLine(Iterable<? extends XExpression> expressions) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var lastLine = -1");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (e : expressions) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val node = e.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (lastLine == node.startLine)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("return false");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("lastLine = node.endLine");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return true");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XConstructorCall expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForFeature(XCONSTRUCTOR_CALL__CONSTRUCTOR).prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (!expr.typeArguments.empty) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\"<\").surround[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (arg : expr.typeArguments) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("arg.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += arg.immediatelyFollowingKeyword(\",\").surround([noSpace], [oneSpace])");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\">\").prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val open = expr.nodeForKeyword(\"(\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += open.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.isMultiParamInOwnLine(format))");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("formatFeatureCallParamsMultiline(open, expr.arguments, format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("formatFeatureCallParamsWrapIfNeeded(open, expr.arguments, format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected void formatFeatureCallTypeParameters(XAbstractFeatureCall expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (!expr.typeArguments.empty) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\"<\").append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (arg : expr.typeArguments) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("arg.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += arg.immediatelyFollowingKeyword(\",\").surround([noSpace], [oneSpace])");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\">\").surround[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XFeatureCall expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val declaringType = expr.nodeForFeature(XFEATURE_CALL__DECLARING_TYPE)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("declaringType.formatStaticQualifier(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += declaringType.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("formatFeatureCallTypeParameters(expr, format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.explicitOperationCall) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val open = expr.nodeForKeyword(\"(\")");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (expr.isMultiParamInOwnLine(format))");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("formatFeatureCallParamsMultiline(open, expr.featureCallArguments, format)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("formatFeatureCallParamsWrapIfNeeded(open, expr.featureCallArguments, format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (arg : expr.featureCallArguments)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format(arg, format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch boolean isMultiParamInOwnLine(XMemberFeatureCall fc, FormattableDocument doc) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val closingBracket = fc.nodeForKeyword(\')\')");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (closingBracket?.hiddenLeafsBefore != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("return closingBracket.hiddenLeafsBefore.newLines > 0");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val params = fc.memberCallArguments.explicitParams");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return params.size > 1 && params.eachExpressionInOwnLine");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch boolean isMultiParamInOwnLine(XFeatureCall fc, FormattableDocument doc) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val closingBracket = fc.nodeForKeyword(\')\')");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (closingBracket?.hiddenLeafsBefore != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("return closingBracket.hiddenLeafsBefore.newLines > 0");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val params = fc.featureCallArguments.explicitParams");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return params.size > 1 && params.eachExpressionInOwnLine");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch boolean isMultiParamInOwnLine(XConstructorCall fc, FormattableDocument doc) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val closingBracket = fc.nodeForKeyword(\')\')");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (closingBracket?.hiddenLeafsBefore != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("return closingBracket.hiddenLeafsBefore.newLines > 0");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val params = fc.arguments.explicitParams");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return params.size > 1 && params.eachExpressionInOwnLine");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XMemberFeatureCall expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var EObject top = expr");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var calls = <XMemberFeatureCall>newArrayList()");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("while (top instanceof XMemberFeatureCall) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("calls += top as XMemberFeatureCall");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("top = (top as XMemberFeatureCall).memberCallTarget");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format(top, format)");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var indented = false");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (call : calls.reverse) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("formatFeatureCallTypeParameters(call, format)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val featureNode = call.nodeForFeature(XABSTRACT_FEATURE_CALL__FEATURE)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val targetNode = call.memberCallTarget.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (targetNode != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("val callOffset = targetNode.offset + targetNode.length");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("val op = call.nodeForKeyword(if (call.nullSafe) \"?.\" else \".\")");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += op.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (call.explicitOperationCall) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("val callNode = call.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("val callLength = callNode.offset + callNode.length - callOffset");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("val open = call.nodeForKeyword(\"(\")");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += featureNode.append[noSpace]");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("val lineLength = format.lineLengthBefore(callOffset)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (call.isMultiParamInOwnLine(format)) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("if (lineLength + featureNode.length < format.cfg.get(maxLineWidth))");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += op.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += op.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("formatFeatureCallParamsMultiline(open, call.memberCallArguments, format)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("if (lineLength + (featureNode.length * 2) < format.cfg.get(maxLineWidth) || format.");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("fitsIntoLine(callOffset, callLength,");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("[ f |");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t");
      _builder.append("f += op.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t\t");
      _builder.append("formatFeatureCallParamsWrapIfNeeded(open, call.memberCallArguments, f)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("])) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += op.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += op.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("if (!indented) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("indented = true");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("format += op.append[increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("formatFeatureCallParamsWrapIfNeeded(open, call.memberCallArguments, format)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("val shortLenght = format.lineLengthBefore(callOffset) + featureNode.length");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (shortLenght < format.cfg.get(maxLineWidth)) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += op.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += op.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("if (!indented) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("indented = true");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += op.append[increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (!call.memberCallArguments.empty) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("val builder = call.memberCallArguments.builder");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("// add single space if lambda is multi-line");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += builder.nodeForEObject.prepend [");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("if (builder.multilineLambda)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("oneSpace");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t\t");
      _builder.append("noSpace");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("builder.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (indented)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += calls.last.nodeForEObject.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected AbstractRule binaryOperationPrecedence(EObject op) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val node = op.nodeForFeature(XABSTRACT_FEATURE_CALL__FEATURE)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (node != null && node.grammarElement instanceof CrossReference) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val terminal = (node.grammarElement as CrossReference).terminal");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (terminal instanceof RuleCall)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("return (terminal as RuleCall).rule");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected boolean isMultiline(XExpression expression, FormattableDocument doc) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val node = expression.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("return node != null && node.startLine != node.endLine");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XBinaryOperation expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var precendece = expr.binaryOperationPrecedence");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var EObject top = expr");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var calls = <XBinaryOperation>newArrayList()");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("while (top.binaryOperationPrecedence == precendece) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("calls += top as XBinaryOperation");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("top = (top as XBinaryOperation).leftOperand");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format(top, format)");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var indented = false");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (call : calls.reverse) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val op = call.nodeForFeature(XABSTRACT_FEATURE_CALL__FEATURE)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += op.prepend[oneSpace]");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (call.rightOperand.isMultiline(format) || format.fitsIntoLine(call.rightOperand)) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += op.append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += op.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (!indented) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("indented = true");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += op.append[increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format(call.rightOperand, format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (indented)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += calls.last.nodeForEObject.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XIfExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.eContainer instanceof XVariableDeclaration) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\"if\").append[increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += expr.nodeForEObject.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val thennode = expr.then.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val elsenode = expr.^else?.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val multiline = thennode?.text?.trim?.contains(\"\\n\") || thennode?.hiddenLeafsBefore?.newLines > 0 ||");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("elsenode?.text?.trim?.contains(\"\\n\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForFeature(XIF_EXPRESSION__IF).surround[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.then instanceof XBlockExpression || multiline)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\"if\").append[cfg(whitespaceBetweenKeywordAndParenthesisML)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\"if\").append[cfg(whitespaceBetweenKeywordAndParenthesisSL)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.then instanceof XBlockExpression) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += thennode.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (expr.^else != null)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += thennode.append[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else if (!multiline) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += thennode.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (expr.^else != null)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += thennode.append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += thennode.prepend[newLine increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (expr.^else != null)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += thennode.append[newLine; decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += thennode.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.^else instanceof XBlockExpression) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += elsenode.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else if (expr.^else instanceof XIfExpression || !multiline) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += elsenode.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += elsenode.prepend[newLine increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += elsenode.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.^if.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.then.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.^else != null)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("expr.^else.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XForLoopExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.nodeForKeyword(\"for\") => [format += append[oneSpace]]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.declaredParam.nodeForEObject => [format += prepend[noSpace] format += append[oneSpace]]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.forExpression.nodeForEObject => [format += prepend[oneSpace] format += append[noSpace]]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val each = expr.eachExpression.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.eachExpression instanceof XBlockExpression) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += each.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += each.prepend[newLine increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += each.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.forExpression.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.eachExpression.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XWhileExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForKeyword(\"while\").append[cfg(whitespaceBetweenKeywordAndParenthesisML)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.predicate.nodeForEObject.surround([noSpace], [noSpace])");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val body = expr.body.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.body instanceof XBlockExpression) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.prepend[newLine increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.predicate.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.body.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XDoWhileExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForKeyword(\"while\").append[cfg(whitespaceBetweenKeywordAndParenthesisML)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.predicate.nodeForEObject.surround([noSpace], [noSpace])");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val body = expr.body.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.body instanceof XBlockExpression) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.append[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.prepend[newLine increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.append[newLine decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.predicate.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.body.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XBlockExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val open = expr.nodeForKeyword(\"{\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if(expr.eContainer == null)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val close = expr.nodeForKeyword(\"}\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (open != null && close != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (expr.expressions.empty) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if(open.hiddenLeafsAfter.containsComment)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += open.append[newLine increaseIndentation decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += open.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += open.append[cfg(blankLinesAroundExpression) increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("for (child : expr.expressions) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("child.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (child != expr.expressions.last || close != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("val childNode = child.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("val sem = childNode.immediatelyFollowingKeyword(\";\")");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("if (sem != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += sem.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += sem.append[cfg(blankLinesAroundExpression)]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t\t");
      _builder.append("format += childNode.append[cfg(blankLinesAroundExpression)]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += close.prepend[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XTypeLiteral expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val typeNode = expr.nodeForFeature(XTYPE_LITERAL__TYPE)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForKeyword(\"typeof\").append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += typeNode.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += typeNode.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var node = typeNode");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("while (node != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("node = node.immediatelyFollowingKeyword(\"[\")");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (node != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += node.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("node = node.immediatelyFollowingKeyword(\"]\")");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (node != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += node.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XThrowExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.expression.nodeForEObject.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.expression.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XReturnExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.expression.nodeForEObject.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.expression.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XTryCatchFinallyExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val body = expr.expression.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.expression instanceof XBlockExpression) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.append[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.prepend[newLine increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.append[newLine decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.expression.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (cc : expr.catchClauses) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("cc.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (cc != expr.catchClauses.last || expr.finallyExpression != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (cc.expression instanceof XBlockExpression)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += cc.nodeForEObject.append[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += cc.nodeForEObject.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.finallyExpression != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val fin = expr.finallyExpression.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (expr.finallyExpression instanceof XBlockExpression) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += fin.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += fin.prepend[newLine increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += fin.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("expr.finallyExpression.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XCatchClause expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForKeyword(\"catch\").append[cfg(whitespaceBetweenKeywordAndParenthesisML)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.declaredParam.nodeForEObject => [format += prepend[noSpace] format += append[noSpace]]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val body = expr.expression.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.expression instanceof XBlockExpression)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.prepend[newLine increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += body.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.declaredParam.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.expression.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(JvmFormalParameter expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.parameterType != null)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += expr.parameterType.nodeForEObject.append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("expr.parameterType.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (obj : expr.eContents)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("switch (obj) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("XExpression: obj.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XSwitchExpression expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val containsBlockExpr = expr.cases.exists[then instanceof XBlockExpression]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val switchSL = !containsBlockExpr && !expr.nodeForEObject.text.trim.contains(\"\\n\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val caseSL = !containsBlockExpr && !expr.cases.exists[nodeForEObject.text.trim.contains(\"\\n\")] && !expr.^default?.nodeForEObject?.text?.contains(\"\\n\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val open = expr.nodeForKeyword(\"{\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val close = expr.nodeForKeyword(\"}\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += expr.nodeForKeyword(\"switch\").append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (switchSL) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (c : expr.cases) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("val cnode = c.then.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += cnode.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += cnode.append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if(expr.^default != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\"default\").append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += expr.^default.nodeForEObject.surround[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else if (caseSL) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.append[newLine; increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (c : expr.cases) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += c.then.nodeForEObject.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (c != expr.cases.last)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += c.nodeForEObject.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if(expr.^default != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\"default\").surround([newLine], [noSpace])");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += expr.^default.nodeForEObject.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += close.prepend[newLine; decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.append[newLine; increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (c : expr.cases) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("val cnode = c.then.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (c.then instanceof XBlockExpression) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += cnode.prepend[cfg(bracesInNewLine)]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (expr.^default != null || c != expr.cases.last)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += cnode.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += cnode.append[newLine; decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += cnode.prepend[newLine; increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("if (expr.^default != null || c != expr.cases.last)");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += cnode.append[newLine; decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t\t\t");
      _builder.append("format += cnode.append[newLine; decreaseIndentationChange = -2]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if(expr.^default != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += expr.nodeForKeyword(\"default\").append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (expr.^default instanceof XBlockExpression) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += expr.^default.nodeForEObject.surround([cfg(bracesInNewLine)], [newLine; decreaseIndentation])");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += expr.^default.nodeForEObject.surround([newLine; increaseIndentation], [newLine; decreaseIndentationChange = -2])");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (c : expr.cases) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (c.typeGuard != null && c.^case != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("val typenode = c.nodeForFeature(XCASE_PART__TYPE_GUARD)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("val casenode = c.nodeForFeature(XCASE_PART__CASE)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += typenode.append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += casenode.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += casenode.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("} else if (c.typeGuard != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("val typenode = c.nodeForFeature(XCASE_PART__TYPE_GUARD)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += typenode.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("} else if (c.^case != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("val casenode = c.nodeForFeature(XCASE_PART__CASE)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += casenode.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += casenode.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("c.^case.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("c.then.format(format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if(expr.^default != null)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("expr.^default.format(format)");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected dispatch void format(XClosure expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val open = expr.nodeForKeyword(\"[\") ");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val close = expr.nodeForKeyword(\"]\")");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("// editingpos");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val children = switch x:expr.expression {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("XBlockExpression: x.expressions");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("default: newArrayList(x)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.declaredFormalParameters.empty && children.empty) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if(open.hiddenLeafsAfter.containsComment)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += open.append[newLine increaseIndentation decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += open.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else if (expr.isMultilineLambda) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("formatClosureMultiLine(expr, open, children, close, format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("formatClosureWrapIfNeeded(expr, open, children, close, format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected void formatClosureMultiLine(XClosure expr, INode open, Collection<XExpression> children, INode close,");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("formatClosureParameters(expr, format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("val explicit = expr.nodeForFeature(XCLOSURE__EXPLICIT_SYNTAX)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (explicit != null) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.append[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += explicit.prepend[oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += explicit.append[newLine; increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.append[newLine; increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (c : children) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("c.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val node = c.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val semicolon = node.immediatelyFollowingKeyword(\";\")");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += semicolon.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (c != children.last)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += (semicolon ?: node).append[newLine]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += close.prepend[newLine; decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected formatClosureParameters(XClosure expr, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.explicitSyntax) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("for (param : expr.declaredFormalParameters) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("param.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += param.immediatelyFollowingKeyword(\",\").surround([noSpace], [oneSpace])");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("\t");
      _builder.append("def protected void formatClosureWrapIfNeeded(XClosure expr, INode open, Collection<XExpression> children,");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("INode close, FormattableDocument format) {");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("formatClosureParameters(expr, format)");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var INode last = open");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (expr.explicitSyntax) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += open.append[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("last = expr.nodeForFeature(XCLOSURE__EXPLICIT_SYNTAX)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += last.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("var indented = false");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("for (c : children) {");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (format.fitsIntoLine(c)) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += last.append[if (children.head == c) noSpace else oneSpace]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("if (!indented) {");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("indented = true");
      _builder.newLine();
      _builder.append("\t\t\t\t\t");
      _builder.append("format += last.append[increaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += last.append[newLine]");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("c.format(format)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("last = c.nodeForEObject");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("val semicolon = last.immediatelyFollowingKeyword(\";\")");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("if (semicolon != null) {");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("format += semicolon.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("last = semicolon");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("if (indented)");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("format += children.last.nodeForEObject.append[decreaseIndentation]");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("format += close.prepend[noSpace]");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final String model = _builder.toString();
      NullProgressMonitor _nullProgressMonitor = new NullProgressMonitor();
      this._syncUtil.yieldToQueuedDisplayJobs(_nullProgressMonitor);
      this.workbench.getIntroManager().closeIntro(this.workbench.getIntroManager().getIntro());
      final XtextEditor editor = this._workbenchTestHelper.openEditor("Foo.xtend", model);
      ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 300, true);
      for (final Integer i : _doubleDotLessThan) {
        {
          IXtextDocument _document = editor.getDocument();
          int _indexOf = model.indexOf("// editingpos");
          int _minus = (_indexOf - 1);
          int _plus = (_minus + (i).intValue());
          String _switchResult = null;
          final int _switchValue = ((i).intValue() % 4);
          switch (_switchValue) {
            case 0:
              _switchResult = "\"\"";
              break;
            case 1:
              _switchResult = "\n\n";
              break;
            case 2:
              _switchResult = "\n\t\n";
              break;
            case 3:
              _switchResult = "\" \"";
              break;
          }
          _document.replace(_plus, 0, _switchResult);
          double _random = Math.random();
          double _multiply = (_random * 1000);
          double _plus_1 = (200 + _multiply);
          final long waitTime = ((long) _plus_1);
          NullProgressMonitor _nullProgressMonitor_1 = new NullProgressMonitor();
          this._syncUtil.yieldToQueuedDisplayJobs(_nullProgressMonitor_1);
          Thread.sleep(waitTime);
          NullProgressMonitor _nullProgressMonitor_2 = new NullProgressMonitor();
          this._syncUtil.yieldToQueuedDisplayJobs(_nullProgressMonitor_2);
        }
      }
      this._workbenchTestHelper.closeEditor(editor, false);
      NullProgressMonitor _nullProgressMonitor_1 = new NullProgressMonitor();
      this._syncUtil.yieldToQueuedDisplayJobs(_nullProgressMonitor_1);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
